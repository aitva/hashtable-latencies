# Hashtable latencies

This benchmark measures the latency of a web service that stores a large
(250K item) hashtable, in multiple languages.

Garbage collected languages are of greater interest, and the Swift version
is mostly used as a reference of what would be ideal.

# Rules for implementations.

* Each HTTP request will add one new item (and remove one if count > 250K)
* Each item will be a new 1KB buffer with every byte initialized to a value.
* Programs will listen on port 8080 and respond with status 200, body "OK"

# Structure

* All program directories are listed in programs.txt
* Every directory should contain `build.sh` and `run.sh`
* [wrk2](https://github.com/giltene/wrk2) must be installed and linked in $PATH as `wrk2`

# Tests

* Warmup: 9K req/s are sent for 60s (initial hash table content)
* Test :  9K req/s are sent by 99 clients concurrently for 180s

# Output:

* All reports are in `reports` directory.
* Charts from both tests can be generated by using [hdrhistogram](http://hdrhistogram.github.io/HdrHistogram/plotFiles.html)

# Current results

![chart](https://github.com/spion/hashtable-latencies/blob/ed3ac5c72f47950ac7ee936365035e6095b32e31/reports/histogram.png)

# Program notes

* go - Go version is go1.6.2 darwin/amd64; uses fasthttp. Using the built-in http library results
  with a lot more work for the GC, and a chart similar to the one seen for Haskell.
* ocaml-reason - This is built with OCaml 4.03+flambda (ReasonML is currently not compatible
  with OCaml 4.03 so the ML version was generated from it using `refmt` first). Follow the
  instructions here: https://ocaml.org/docs/install.html
* node - Requires node 6.x (`Buffer.alloc` API)
* haskell - Should build easily if you have [stack][his]
* swift-zewo - You should setup [swiftenv to the right snapshot][swiftenv]

# Conclusions

Want to build low-latency, memory-intensive services in a GCed language? Use
OCaml (or Reason if you prefer the syntax).

# OCaml GC notes

Other things that were attempted to make the latency worse for OCaml:

* random buffer sizes
* longer running time

Things to try:

* delete keys out of order (might increase heap compaction duration?)

Concerns:
* ~~memory usage is very big: The OCaml version achieves a steady-state of 4GB used~~ - This was due to incorrectly using an array of 1024 chars instead of a Buffer. Since OCaml data types are all machine-word-sized, this resulted with 8KB buffers instead of 1KB buffers. Switching to the `Buffer` datatype eliminated this problem and brought down memory usage to ~ 500MB, which is comparable with the other languages (300MB-800MB)
* initial phase has slightly bigger latency: During the first 1 minute, the latency may go up to 25ms



[rii]: https://github.com/facebook/reason/blob/master/README.md#install-stable
[his]: http://docs.haskellstack.org/en/stable/README/#how-to-install
[swiftenv]: https://github.com/Zewo/Zewo#swiftenv
